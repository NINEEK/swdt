<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ˜Ÿç©ºæ€ç»´å¯¼å›¾ - é‡å­æ¶æ„ç‰ˆ v2.1</title>
    <style>
body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
    background: #0f142b url('https://images.unsplash.com/photo-1451187580459-43490279c0fa?auto=format&fit=crop&w=1772&q=80') center/cover no-repeat;
    color: #e0e0e0;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    user-select: none;
    position: relative;
}

body::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.3);
    pointer-events: none;
    z-index: 0;
}

#app { 
    display: flex; 
    width: 100%; 
    height: 100%; 
    position: relative; 
    z-index: 1;
}

/* é‡å­æ§åˆ¶ç•Œé¢ */
#celestial-menu-toggle {
    position: absolute; 
    top: 28px; 
    right: 28px;
    width: 36px; 
    height: 36px; 
    background: linear-gradient(135deg, #ffffff 0%, #e6f0ff 100%);
    border-radius: 50%; 
    cursor: pointer;
    box-shadow: 
        0 0 25px 10px rgba(120,180,255,0.8),
        inset 0 0 10px rgba(255,255,255,0.5);
    animation: quantum-pulse 2.5s infinite alternate;
    z-index: 1001;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    align-items: center;
    justify-content: center;
}

#celestial-menu-toggle::after {
    content: 'â˜°';
    font-size: 18px;
    color: #1a2744;
    font-weight: bold;
}

#celestial-menu-toggle:hover {
    transform: scale(1.15) rotate(90deg);
    box-shadow: 
        0 0 35px 15px rgba(120,180,255,1),
        inset 0 0 15px rgba(255,255,255,0.7);
}

@keyframes quantum-pulse {
    0%   { box-shadow: 0 0 20px 8px #78b4ffcc, inset 0 0 8px rgba(255,255,255,0.4); }
    100% { box-shadow: 0 0 35px 15px #a8d0ff, inset 0 0 12px rgba(255,255,255,0.6); }
}

/* é‡å­èœå•é¢æ¿ */
#celestial-menu-options {
    display: none; 
    position: absolute; 
    top: 76px; 
    right: 24px;
    background: rgba(18, 24, 48, 0.98);
    border: 1px solid #4a90e255;
    border-radius: 16px; 
    padding: 24px 20px 20px 20px;
    min-width: 280px; 
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 
        0px 20px 50px rgba(0,0,0,0.7),
        0px 0px 100px rgba(78,150,255,0.15);
    z-index: 1000;
    backdrop-filter: blur(20px);
    animation: menu-slide-in 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes menu-slide-in {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.menu-header {
    font-size: 1.15em; 
    color: #8fc8ff; 
    margin-bottom: 14px;
    font-weight: 700; 
    letter-spacing: 1.5px; 
    text-align: left;
    border-bottom: 2px solid #4a90e244; 
    padding-bottom: 10px;
    margin-top: 16px;
    text-transform: uppercase;
}

.menu-header:first-child {
    margin-top: 0;
}

.menu-item {
    color: #e6f2ff; 
    background: rgba(255,255,255,0.04);
    margin: 10px 0; 
    padding: 14px 22px;
    cursor: pointer; 
    border-radius: 8px;
    font-size: 1.02em; 
    font-weight: 500;
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    border: 1px solid transparent;
    position: relative;
    overflow: hidden;
}

.menu-item::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(78,150,255,0.3), transparent);
    transition: left 0.5s;
}

.menu-item:hover::before {
    left: 100%;
}

.menu-item:hover {
    background: rgba(78,150,255,0.3); 
    color: #fff;
    border-color: #4e96ff66;
    transform: translateX(5px);
    box-shadow: 0 4px 15px rgba(78,150,255,0.3);
}

.menu-item:active {
    transform: translateX(3px) scale(0.98);
}

.menu-item.layout-option.active,
.menu-item.toggle-active {
    background: rgba(78,150,255,0.45);
    border-color: #4e96ff88;
    color: #fff;
    box-shadow: 
        0 4px 20px rgba(78,150,255,0.4),
        inset 0 0 10px rgba(255,255,255,0.1);
}

/* å·¥ä½œåŒºç®¡ç†é¢æ¿ */
#workspace-panel {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(18, 24, 48, 0.98);
    border: 2px solid #4a90e288;
    border-radius: 20px;
    padding: 32px;
    min-width: 420px;
    max-width: 90vw;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 
        0px 30px 80px rgba(0,0,0,0.8),
        0px 0px 150px rgba(78,150,255,0.2);
    z-index: 2000;
    backdrop-filter: blur(30px);
    animation: modal-appear 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes modal-appear {
    from {
        opacity: 0;
        transform: translate(-50%, -45%) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

.workspace-header {
    font-size: 1.5em;
    color: #a8d0ff;
    margin-bottom: 24px;
    text-align: center;
    font-weight: 700;
    letter-spacing: 2px;
    text-transform: uppercase;
}

.workspace-list {
    margin: 20px 0;
    max-height: 300px;
    overflow-y: auto;
}

.workspace-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 18px;
    margin: 8px 0;
    background: rgba(255,255,255,0.05);
    border: 1px solid #4a90e233;
    border-radius: 10px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.workspace-item:hover {
    background: rgba(78,150,255,0.15);
    border-color: #4a90e266;
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(78,150,255,0.25);
}

.workspace-item.active {
    background: rgba(78,150,255,0.3);
    border-color: #4e96ff88;
    box-shadow: 
        0 6px 25px rgba(78,150,255,0.35),
        inset 0 0 10px rgba(255,255,255,0.1);
}

.workspace-name {
    font-size: 1.1em;
    color: #e6f2ff;
    font-weight: 500;
    flex-grow: 1;
}

.workspace-actions {
    display: flex;
    gap: 8px;
}

.workspace-btn {
    padding: 6px 12px;
    background: rgba(255,255,255,0.1);
    border: 1px solid #4a90e244;
    border-radius: 6px;
    color: #a8d0ff;
    font-size: 0.85em;
    cursor: pointer;
    transition: all 0.25s;
}

.workspace-btn:hover {
    background: rgba(78,150,255,0.3);
    border-color: #4e96ff66;
    color: #fff;
    transform: translateY(-1px);
}

.workspace-new-input {
    width: 100%;
    padding: 12px 16px;
    background: rgba(255,255,255,0.08);
    border: 2px solid #4a90e266;
    border-radius: 8px;
    color: #fff;
    font-size: 1.05em;
    margin: 16px 0;
    outline: none;
    transition: all 0.3s;
}

.workspace-new-input:focus {
    background: rgba(255,255,255,0.12);
    border-color: #4e96ff88;
    box-shadow: 0 0 20px rgba(78,150,255,0.4);
}

.workspace-panel-actions {
    display: flex;
    justify-content: center;
    gap: 16px;
    margin-top: 24px;
}

.panel-btn {
    padding: 12px 28px;
    background: linear-gradient(135deg, #4e96ff 0%, #3d7ae6 100%);
    border: none;
    border-radius: 8px;
    color: white;
    font-size: 1.05em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(78,150,255,0.4);
}

.panel-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 25px rgba(78,150,255,0.6);
}

.panel-btn.secondary {
    background: rgba(255,255,255,0.1);
    border: 1px solid #4a90e266;
}

/* å¿«é€Ÿå·¥å…·æ  */
#quick-toolbar {
    position: absolute;
    top: 28px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 12px;
    background: rgba(18, 24, 48, 0.9);
    padding: 8px 16px;
    border-radius: 20px;
    border: 1px solid #4a90e244;
    backdrop-filter: blur(20px);
    z-index: 900;
}

.toolbar-btn {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: rgba(255,255,255,0.08);
    border: 1px solid #4a90e233;
    color: #a8d0ff;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.25s;
    font-size: 18px;
}

.toolbar-btn:hover {
    background: rgba(78,150,255,0.3);
    border-color: #4e96ff66;
    color: #fff;
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(78,150,255,0.5);
}

.toolbar-btn.active {
    background: rgba(78,150,255,0.45);
    border-color: #4e96ff88;
    color: #fff;
}

/* å­é¢æ¿æ ·å¼ä¼˜åŒ– */
.sub-panel {
    display: none;
    position: absolute;
    top: 76px;
    right: 320px;
    background: rgba(18, 24, 48, 0.98);
    border: 1px solid #4a90e255;
    border-radius: 16px;
    padding: 20px;
    min-width: 240px;
    box-shadow: 
        0px 20px 50px rgba(0,0,0,0.7),
        0px 0px 80px rgba(78,150,255,0.1);
    z-index: 999;
    backdrop-filter: blur(20px);
    animation: menu-slide-in 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.sub-panel-header {
    font-size: 1.15em;
    color: #8fc8ff;
    margin-bottom: 16px;
    font-weight: 600;
    letter-spacing: 1px;
    text-transform: uppercase;
}

.bg-preset-item {
    color: #e6f2ff;
    background: rgba(255,255,255,0.05);
    margin: 10px 0;
    padding: 12px 18px;
    cursor: pointer;
    border-radius: 8px;
    font-size: 0.98em;
    transition: all 0.3s;
    border: 1px solid transparent;
}

.bg-preset-item:hover {
    background: rgba(78,150,255,0.25);
    border-color: #4e96ff44;
    transform: translateX(3px);
}

.bg-preset-item.active {
    background: rgba(78,150,255,0.4);
    border-color: #4e96ff66;
    box-shadow: inset 0 0 10px rgba(255,255,255,0.1);
}

#color-picker-panel {
    text-align: center;
}

#bgColorPicker {
    width: 100%;
    height: 50px;
    margin: 16px 0;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

#applyColorBg {
    background: linear-gradient(135deg, #4e96ff 0%, #3d7ae6 100%);
    color: white;
    border: none;
    padding: 10px 28px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.05em;
    font-weight: 600;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(78,150,255,0.4);
}

#applyColorBg:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 25px rgba(78,150,255,0.6);
}

/* å¯¼å›¾å®¹å™¨ä¸ç”»å¸ƒ */
#mind-map-container { 
    flex-grow: 1; 
    position: relative; 
    overflow: hidden; 
    cursor: grab; 
}

#mind-map-container.grabbing { 
    cursor: grabbing; 
}

#mind-map-canvas { 
    position: absolute; 
    width: 100%; 
    height: 100%; 
    background: transparent; 
    transform-origin: 0 0; 
}

/* é‡å­èŠ‚ç‚¹æ ·å¼ç³»ç»Ÿ */
.node {
    position: absolute; 
    border-radius: 50%;
    cursor: pointer; 
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 10; 
    width: 26px; 
    height: 26px;
    background: radial-gradient(circle at 30% 30%, #ffffff 0%, #b8d4ff 25%, #7aaaff 50%, transparent 90%);
    box-shadow: 
        0 0 15px 5px #a8ccffdd, 
        0 0 25px 10px #7aaaff77,
        inset 0 0 10px rgba(255,255,255,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0;
}

.node.root-node {
    width: 40px; 
    height: 40px;
    background: radial-gradient(circle at 30% 30%, #ffffff 0%, #cce4ff 20%, #8fc3ff 45%, transparent 85%);
    box-shadow:
        0 0 25px 10px #fff, 
        0 0 40px 18px #b8e0ffaa,
        0 0 60px 30px #7ac8ff55,
        inset 0 0 15px rgba(255,255,255,0.7);
    animation: root-quantum-glow 3s infinite alternate;
}

@keyframes root-quantum-glow {
    0%   { 
        box-shadow: 
            0 0 25px 10px #fff, 
            0 0 40px 18px #b8e0ffaa,
            0 0 60px 30px #7ac8ff55,
            inset 0 0 15px rgba(255,255,255,0.7);
        transform: scale(1);
    }
    100% { 
        box-shadow: 
            0 0 35px 15px #fff, 
            0 0 55px 28px #a8d8ffdd,
            0 0 80px 40px #6fc4ff77,
            inset 0 0 20px rgba(255,255,255,0.9);
        transform: scale(1.05);
    }
}

.node:hover {
    transform: scale(1.25); 
    filter: brightness(140%);
    box-shadow: 
        0 0 20px 8px #cce9ff, 
        0 0 40px 18px #8fd4ffaa,
        inset 0 0 12px rgba(255,255,255,0.8);
    z-index: 15;
}

.node.selected {
    box-shadow: 
        0 0 25px 12px #6fc4ffff, 
        0 0 45px 20px #4eb6ffaa,
        inset 0 0 15px rgba(255,255,255,0.9);
    transform: scale(1.15);
}

/* èŠ‚ç‚¹æ–‡æœ¬æ˜¾ç¤ºç³»ç»Ÿ */
.node-text {
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-top: 10px;
    color: #ffffff;
    font-size: 14px;
    font-weight: 500;
    white-space: nowrap;
    text-shadow: 
        0 0 10px #000000cc,
        0 0 20px #4a90e288;
    pointer-events: none;
    max-width: 180px;
    overflow: hidden;
    text-overflow: ellipsis;
    transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.root-node .node-text {
    font-size: 17px;
    font-weight: 600;
    margin-top: 14px;
    max-width: 220px;
}

/* æ–‡æœ¬éšè—çŠ¶æ€ */
body.text-hidden .node-text {
    opacity: 0;
    pointer-events: none;
}

body.text-hidden .node-text.editing-temp-show {
    opacity: 1;
}

/* ç¼–è¾‘è¾“å…¥æ¡† */
.node-input {
    position: absolute;
    background: rgba(255,255,255,0.96);
    color: #1a2744; 
    border: 2px solid #7ec8ff;
    padding: 12px 16px; 
    border-radius: 10px;
    z-index: 101; 
    min-width: 180px; 
    max-width: 380px;
    font-size: 1.05em; 
    font-family: inherit;
    box-shadow: 
        0 0 30px 12px #a8d0ff, 
        0 6px 25px rgba(0,0,0,0.35);
    outline: none; 
    resize: none; 
    line-height: 1.5; 
    box-sizing: border-box;
    animation: input-glow-pulse 2s infinite alternate;
}

@keyframes input-glow-pulse {
    0%   { 
        box-shadow: 
            0 0 25px 10px #b8e0ff, 
            0 6px 20px rgba(0,0,0,0.3);
    }
    100% { 
        box-shadow: 
            0 0 40px 18px #8fd4ff, 
            0 8px 30px rgba(0,0,0,0.4);
    }
}

.node-input:focus {
    background: #ffffff;
    color: #0f1a33;
    border-color: #4eb6ff;
    box-shadow: 
        0 0 45px 20px #6fc4ffdd, 
        0 8px 35px rgba(0,0,0,0.45);
}

/* SVGè¿çº¿ç³»ç»Ÿ */
#lines-svg { 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    pointer-events: none; 
    z-index: 1; 
}

.connection-line {
    stroke: #a8d0ff;
    stroke-width: 3.5px; 
    fill: none;
    stroke-linecap: round;
    filter: drop-shadow(0 0 6px #7ec8ff88);
    opacity: 0.85;
    transition: stroke 0.3s, opacity 0.3s;
}

.connection-path {
    stroke: #a8d0ff;
    stroke-width: 3.5px;
    fill: none;
    stroke-linecap: round;
    filter: drop-shadow(0 0 6px #7ec8ff88);
    opacity: 0.85;
    transition: stroke 0.3s, opacity 0.3s;
}

/* å³é”®èœå• */
#node-context-menu {
    display: none; 
    position: absolute;
    background: rgba(20,30,55,0.98);
    border: 1px solid #4a90e2;
    border-radius: 12px; 
    padding: 14px 0;
    z-index: 200; 
    box-shadow: 
        0px 12px 35px rgba(0,0,0,0.6),
        0px 0px 50px rgba(78,150,255,0.15); 
    min-width: 180px;
    backdrop-filter: blur(20px);
    animation: context-menu-appear 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes context-menu-appear {
    from {
        opacity: 0;
        transform: scale(0.9);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

#node-context-menu .context-menu-item {
    padding: 14px 24px; 
    color: #e6f2ff;
    cursor: pointer; 
    font-size: 0.98em; 
    transition: all 0.25s;
    position: relative;
}

#node-context-menu .context-menu-item:hover {
    background: #4e96ff44; 
    color: #fff;
    padding-left: 30px;
}

/* ç”¨æˆ·æ ‡è¯† */
#user-logo {
    position: absolute; 
    bottom: 24px; 
    left: 50%;
    transform: translateX(-50%);
    color: #a8d0ffee; 
    font-size: 1.1em; 
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    text-shadow: 0 0 15px #7ec8ff99;
    z-index: 5; 
    pointer-events: none;
    white-space: nowrap; 
    text-align: center;
    letter-spacing: 1.5px;
    font-weight: 500;
}

/* çŠ¶æ€æŒ‡ç¤ºå™¨ */
#status-indicator {
    position: absolute;
    bottom: 24px;
    right: 24px;
    background: rgba(18, 24, 48, 0.9);
    padding: 10px 20px;
    border-radius: 20px;
    border: 1px solid #4a90e244;
    color: #a8d0ff;
    font-size: 0.9em;
    backdrop-filter: blur(20px);
    display: none;
    animation: status-fade-in 0.3s;
}

@keyframes status-fade-in {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* ç§»åŠ¨ç«¯é€‚é…ä¼˜åŒ– */
@media (max-width: 768px) {
    #celestial-menu-options {
        min-width: 92vw; 
        left: 50%;
        transform: translateX(-50%);
        right: auto; 
        top: auto; 
        bottom: 0; 
        border-radius: 24px 24px 0 0;
        box-shadow: 0 -10px 50px rgba(0,0,0,0.8);
        padding: 24px 4vw 32px 4vw;
        max-height: 75vh;
        overflow-y: auto;
    }
    
    #workspace-panel {
        min-width: 90vw;
        padding: 24px;
    }
    
    .sub-panel {
        left: 50%;
        transform: translateX(-50%);
        right: auto;
        top: 50%;
        transform: translate(-50%, -50%);
        min-width: 85vw;
    }
    
    #celestial-menu-toggle { 
        top: auto; 
        bottom: 24px; 
        right: 24px; 
        width: 48px; 
        height: 48px;
    }
    
    #celestial-menu-toggle::after {
        font-size: 22px;
    }
    
    #quick-toolbar {
        top: auto;
        bottom: 24px;
        padding: 6px 12px;
        gap: 8px;
    }
    
    .toolbar-btn {
        width: 32px;
        height: 32px;
        font-size: 16px;
    }
    
    .menu-header, #user-logo { 
        font-size: 1.2em;
    }
    
    .menu-item { 
        font-size: 1.08em; 
        padding: 16px 18px;
    }
    
    .node-input { 
        min-width: 160px; 
        max-width: 85vw; 
        font-size: 1.08em;
    }
    
    .node-text {
        font-size: 13px;
    }
    
    .root-node .node-text {
        font-size: 15px;
    }
}

/* é«˜çº§åŠ¨ç”»ä¼˜åŒ– */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
}

/* æ»šåŠ¨æ¡ç¾åŒ– */
::-webkit-scrollbar { 
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.05);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: rgba(78,150,255,0.5);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(78,150,255,0.7);
}

/* é€‰æ‹©æ•ˆæœä¼˜åŒ– */
::selection {
    background: #4e96ff66;
    color: #fff;
}

/* æ‰“å°ä¼˜åŒ– */
@media print {
    body::before,
    #celestial-menu-toggle,
    #celestial-menu-options,
    #quick-toolbar,
    #workspace-panel,
    .sub-panel,
    #node-context-menu,
    #status-indicator {
        display: none !important;
    }
    
    body {
        background: white !important;
    }
    
    .node-text {
        color: #000 !important;
        text-shadow: none !important;
    }
}
    </style>
</head>
<body>
    <div id="app">
        <!-- é‡å­æ§åˆ¶ä¸­å¿ƒ -->
        <div id="celestial-menu-toggle" title="é‡å­æ§åˆ¶ä¸­å¿ƒ"></div>
        
        <!-- å¿«é€Ÿå·¥å…·æ  -->
        <div id="quick-toolbar">
            <div class="toolbar-btn" id="quick-add-child" title="æ·»åŠ å­èŠ‚ç‚¹">+</div>
            <div class="toolbar-btn" id="quick-toggle-text" title="æ˜¾ç¤º/éšè—æ–‡æœ¬">ğŸ‘</div>
            <div class="toolbar-btn" id="quick-focus-root" title="èšç„¦æ ¹èŠ‚ç‚¹">âŠ™</div>
            <div class="toolbar-btn" id="quick-export" title="å¿«é€Ÿå¯¼å‡º">â¬‡</div>
        </div>
        
        <!-- ä¸»èœå•é¢æ¿ -->
        <div id="celestial-menu-options">
            <div class="menu-header">æ ¸å¿ƒæ“ä½œ</div>
            <div class="menu-item" id="addRootNode">+ åˆ›å»ºä¸»èŠ‚ç‚¹</div>
            <div class="menu-item" id="toggleTextVisibility">ğŸ‘ æ–‡æœ¬æ˜¾éšåˆ‡æ¢</div>
            <div class="menu-item" id="workspaceManager">ğŸ“ å·¥ä½œåŒºç®¡ç†</div>
            <div class="menu-item" id="clearMap">ğŸ—‘ æ¸…ç©ºç”»å¸ƒ</div>
            <div class="menu-item" id="exportJSON">â¬‡ å¯¼å‡ºæ•°æ®</div>
            <div class="menu-item" id="importJSON">â¬† å¯¼å…¥æ•°æ®</div>
            <div class="menu-item" id="exportImage">ğŸ“¸ å¯¼å‡ºå›¾ç‰‡</div>
            
            <div class="menu-header">å¸ƒå±€æ¨¡å¼</div>
            <div class="menu-item layout-option active" data-layout="free">âœ¨ è‡ªç”±å¸ƒå±€</div>
            <div class="menu-item layout-option" data-layout="tree">ğŸŒ² å±‚çº§æ ‘å›¾</div>
            <div class="menu-item layout-option" data-layout="org">ğŸ“Š ç»„ç»‡æ¶æ„</div>
            <div class="menu-item layout-option" data-layout="fishbone">ğŸŸ é±¼éª¨åˆ†æ</div>
            
            <div class="menu-header">è§†è§‰å®šåˆ¶</div>
            <div class="menu-item" id="bgPresets">ğŸ–¼ é¢„è®¾èƒŒæ™¯</div>
            <div class="menu-item" id="bgColor">ğŸ¨ è‡ªå®šä¹‰é¢œè‰²</div>
        </div>
        
        <!-- å·¥ä½œåŒºç®¡ç†é¢æ¿ -->
        <div id="workspace-panel">
            <div class="workspace-header">å·¥ä½œåŒºç®¡ç†ä¸­å¿ƒ</div>
            <div class="workspace-list" id="workspaceList">
                <!-- åŠ¨æ€ç”Ÿæˆå·¥ä½œåŒºåˆ—è¡¨ -->
            </div>
            <input type="text" class="workspace-new-input" id="newWorkspaceName" placeholder="è¾“å…¥æ–°å·¥ä½œåŒºåç§°...">
            <div class="workspace-panel-actions">
                <button class="panel-btn" id="createWorkspace">åˆ›å»ºå·¥ä½œåŒº</button>
                <button class="panel-btn secondary" id="closeWorkspacePanel">å…³é—­</button>
            </div>
        </div>
        
        <!-- èƒŒæ™¯é¢„è®¾é¢æ¿ -->
        <div id="bg-preset-panel" class="sub-panel">
            <div class="sub-panel-header">èƒŒæ™¯ä¸»é¢˜</div>
            <div class="bg-preset-item active" data-bg="url('https://images.unsplash.com/photo-1451187580459-43490279c0fa?auto=format&fit=crop&w=1772&q=80')">æ·±é‚ƒæ˜Ÿç©º</div>
            <div class="bg-preset-item" data-bg="url('https://images.unsplash.com/photo-1534796636912-3b95b3ab5986?auto=format&fit=crop&w=1771&q=80')">ç´«è‰²æ˜Ÿäº‘</div>
            <div class="bg-preset-item" data-bg="url('https://images.unsplash.com/photo-1419242902214-272b3f66ee7a?auto=format&fit=crop&w=1787&q=80')">ç’€ç’¨é“¶æ²³</div>
            <div class="bg-preset-item" data-bg="linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)">æ·±è“æ¸å˜</div>
            <div class="bg-preset-item" data-bg="linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%)">ç§‘æŠ€é»‘è“</div>
            <div class="bg-preset-item" data-bg="linear-gradient(135deg, #232526 0%, #414345 100%)">ä¼˜é›…ç°åº¦</div>
        </div>
        
        <!-- é¢œè‰²é€‰æ‹©é¢æ¿ -->
        <div id="color-picker-panel" class="sub-panel">
            <div class="sub-panel-header">è‡ªå®šä¹‰èƒŒæ™¯è‰²</div>
            <input type="color" id="bgColorPicker" value="#0f142b">
            <button id="applyColorBg">åº”ç”¨é¢œè‰²</button>
        </div>
        
        <!-- æ€ç»´å¯¼å›¾å®¹å™¨ -->
        <div id="mind-map-container">
            <div id="mind-map-canvas"></div>
            <svg id="lines-svg"></svg>
        </div>
        
        <!-- èŠ‚ç‚¹å³é”®èœå• -->
        <div id="node-context-menu">
            <div class="context-menu-item" id="ctx-add-child">+ æ·»åŠ å­èŠ‚ç‚¹</div>
            <div class="context-menu-item" id="ctx-edit-node">âœï¸ ç¼–è¾‘å†…å®¹</div>
            <div class="context-menu-item" id="ctx-delete-node">ğŸ—‘ åˆ é™¤èŠ‚ç‚¹</div>
            <div class="context-menu-item" id="ctx-focus-node">âŠ™ èšç„¦æ­¤èŠ‚ç‚¹</div>
        </div>
        
        <!-- ç”¨æˆ·æ ‡è¯† -->
        <div id="user-logo">é’Ÿæ„ - æ˜Ÿè¾°ç»˜å· Â· é‡å­æ¶æ„</div>
        
        <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
        <div id="status-indicator"></div>
    </div>
    <script>
// é‡å­æ¶æ„æ€ç»´å¯¼å›¾ç³»ç»Ÿ v2.1
document.addEventListener('DOMContentLoaded', () => {
    // DOMå¼•ç”¨æ˜ å°„
    const DOM = {
        // ä¸»æ§åˆ¶
        menuToggle: document.getElementById('celestial-menu-toggle'),
        menuOptions: document.getElementById('celestial-menu-options'),
        
        // å¿«é€Ÿå·¥å…·æ 
        quickToolbar: document.getElementById('quick-toolbar'),
        quickAddChild: document.getElementById('quick-add-child'),
        quickToggleText: document.getElementById('quick-toggle-text'),
        quickFocusRoot: document.getElementById('quick-focus-root'),
        quickExport: document.getElementById('quick-export'),
        
        // èœå•é¡¹
        addRootNode: document.getElementById('addRootNode'),
        toggleTextVisibility: document.getElementById('toggleTextVisibility'),
        workspaceManager: document.getElementById('workspaceManager'),
        clearMap: document.getElementById('clearMap'),
        importJSON: document.getElementById('importJSON'),
        exportJSON: document.getElementById('exportJSON'),
        exportImage: document.getElementById('exportImage'),
        
        // å·¥ä½œåŒºç®¡ç†
        workspacePanel: document.getElementById('workspace-panel'),
        workspaceList: document.getElementById('workspaceList'),
        newWorkspaceName: document.getElementById('newWorkspaceName'),
        createWorkspace: document.getElementById('createWorkspace'),
        closeWorkspacePanel: document.getElementById('closeWorkspacePanel'),
        
        // ç”»å¸ƒ
        container: document.getElementById('mind-map-container'),
        canvas: document.getElementById('mind-map-canvas'),
        linesSvg: document.getElementById('lines-svg'),
        
        // å³é”®èœå•
        contextMenu: document.getElementById('node-context-menu'),
        ctxAddChild: document.getElementById('ctx-add-child'),
        ctxEditNode: document.getElementById('ctx-edit-node'),
        ctxDeleteNode: document.getElementById('ctx-delete-node'),
        ctxFocusNode: document.getElementById('ctx-focus-node'),
        
        // èƒŒæ™¯è®¾ç½®
        bgPresets: document.getElementById('bgPresets'),
        bgColor: document.getElementById('bgColor'),
        bgPresetPanel: document.getElementById('bg-preset-panel'),
        colorPickerPanel: document.getElementById('color-picker-panel'),
        applyColorBg: document.getElementById('applyColorBg'),
        bgColorPicker: document.getElementById('bgColorPicker'),
        
        // å…¶ä»–
        statusIndicator: document.getElementById('status-indicator')
    };

    // å…¨å±€çŠ¶æ€ç®¡ç†
    const State = {
        nodes: [],
        nodeIdCounter: 0,
        selectedNodeId: null,
        isMenuOpen: false,
        draggingNode: null,
        dragOffset: { x: 0, y: 0 },
        activeInput: null,
        panZoom: { scale: 1, offsetX: 0, offsetY: 0, isPanning: false, lastPanX: 0, lastPanY: 0 },
        currentLayout: 'free',
        currentBackground: `url('https://images.unsplash.com/photo-1451187580459-43490279c0fa?auto=format&fit=crop&w=1772&q=80')`,
        textVisible: true,
        currentWorkspaceId: 'default',
        workspaces: {}
    };

    // å¸ƒå±€é…ç½®
    const LAYOUT_CONFIG = {
        tree: { nodeSpacingX: 220, nodeSpacingY: 90, startX: 120 },
        org: { nodeSpacingX: 160, nodeSpacingY: 130, startY: 120 },
        fishbone: { mainSpacing: 320, branchSpacingY: 110, branchSpacingX: 170 }
    };

    // === å·¥ä½œåŒºç®¡ç†ç³»ç»Ÿ ===
    function initWorkspaceSystem() {
        const savedWorkspaces = localStorage.getItem('quantum_workspaces');
        if (savedWorkspaces) {
            try {
                State.workspaces = JSON.parse(savedWorkspaces);
            } catch (e) {
                State.workspaces = {};
            }
        }
        
        // ç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªé»˜è®¤å·¥ä½œåŒº
        if (!State.workspaces.default) {
            State.workspaces.default = {
                id: 'default',
                name: 'é»˜è®¤å·¥ä½œåŒº',
                data: {
                    nodes: [],
                    nodeIdCounter: 0,
                    panZoom: { scale: 1, offsetX: 0, offsetY: 0 },
                    currentLayout: 'free',
                    currentBackground: State.currentBackground,
                    textVisible: true
                },
                createdAt: Date.now(),
                lastModified: Date.now()
            };
        }
    }

    function saveWorkspaces() {
        localStorage.setItem('quantum_workspaces', JSON.stringify(State.workspaces));
    }

    function saveCurrentWorkspace() {
        const workspace = State.workspaces[State.currentWorkspaceId];
        if (workspace) {
            workspace.data = {
                nodes: State.nodes,
                nodeIdCounter: State.nodeIdCounter,
                panZoom: State.panZoom,
                currentLayout: State.currentLayout,
                currentBackground: State.currentBackground,
                textVisible: State.textVisible
            };
            workspace.lastModified = Date.now();
            saveWorkspaces();
        }
    }

    function loadWorkspace(workspaceId) {
        saveCurrentWorkspace(); // ä¿å­˜å½“å‰å·¥ä½œåŒº
        
        const workspace = State.workspaces[workspaceId];
        if (!workspace) return;
        
        State.currentWorkspaceId = workspaceId;
        const data = workspace.data;
        
        // æ¸…ç©ºç”»å¸ƒ
        DOM.canvas.innerHTML = '';
        DOM.linesSvg.innerHTML = '';
        
        // åŠ è½½æ•°æ®
        State.nodes = data.nodes || [];
        State.nodeIdCounter = data.nodeIdCounter || 0;
        State.currentLayout = data.currentLayout || 'free';
        State.currentBackground = data.currentBackground || State.currentBackground;
        State.textVisible = data.textVisible !== false;
        State.panZoom = { ...State.panZoom, ...data.panZoom };
        
        // åº”ç”¨çŠ¶æ€
        applyBackground();
        applyTextVisibility();
        applyCanvasTransform();
        
        // æ›´æ–°UIçŠ¶æ€
        document.querySelectorAll('.layout-option').forEach(item => {
            item.classList.toggle('active', item.dataset.layout === State.currentLayout);
        });
        
        // æ¸²æŸ“èŠ‚ç‚¹
        State.nodes.forEach(renderNode);
        if (State.currentLayout !== 'free') {
            applyLayout(State.currentLayout);
        }
        drawLines();
        
        showStatus(`å·²åˆ‡æ¢åˆ°å·¥ä½œåŒºï¼š${workspace.name}`);
    }

    function createNewWorkspace(name) {
        const id = 'workspace_' + Date.now();
        State.workspaces[id] = {
            id: id,
            name: name || 'æ–°å·¥ä½œåŒº',
            data: {
                nodes: [],
                nodeIdCounter: 0,
                panZoom: { scale: 1, offsetX: 0, offsetY: 0 },
                currentLayout: 'free',
                currentBackground: State.currentBackground,
                textVisible: true
            },
            createdAt: Date.now(),
            lastModified: Date.now()
        };
        saveWorkspaces();
        loadWorkspace(id);
        updateWorkspaceList();
    }

    function deleteWorkspace(workspaceId) {
        if (workspaceId === 'default') {
            showStatus('é»˜è®¤å·¥ä½œåŒºæ— æ³•åˆ é™¤');
            return;
        }
        
        if (confirm('ç¡®å®šè¦åˆ é™¤æ­¤å·¥ä½œåŒºå—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚')) {
            delete State.workspaces[workspaceId];
            saveWorkspaces();
            
            if (State.currentWorkspaceId === workspaceId) {
                loadWorkspace('default');
            }
            updateWorkspaceList();
            showStatus('å·¥ä½œåŒºå·²åˆ é™¤');
        }
    }

    function renameWorkspace(workspaceId, newName) {
        const workspace = State.workspaces[workspaceId];
        if (workspace && newName.trim()) {
            workspace.name = newName.trim();
            workspace.lastModified = Date.now();
            saveWorkspaces();
            updateWorkspaceList();
            showStatus('å·¥ä½œåŒºå·²é‡å‘½å');
        }
    }

    function updateWorkspaceList() {
        DOM.workspaceList.innerHTML = '';
        
        Object.values(State.workspaces).forEach(workspace => {
            const item = document.createElement('div');
            item.className = 'workspace-item';
            if (workspace.id === State.currentWorkspaceId) {
                item.classList.add('active');
            }
            
            const nameEl = document.createElement('div');
            nameEl.className = 'workspace-name';
            nameEl.textContent = workspace.name;
            
            const actions = document.createElement('div');
            actions.className = 'workspace-actions';
            
            const loadBtn = document.createElement('button');
            loadBtn.className = 'workspace-btn';
            loadBtn.textContent = 'åŠ è½½';
            loadBtn.onclick = () => {
                loadWorkspace(workspace.id);
                DOM.workspacePanel.style.display = 'none';
            };
            
            const renameBtn = document.createElement('button');
            renameBtn.className = 'workspace-btn';
            renameBtn.textContent = 'é‡å‘½å';
            renameBtn.onclick = () => {
                const newName = prompt('è¾“å…¥æ–°åç§°ï¼š', workspace.name);
                if (newName) renameWorkspace(workspace.id, newName);
            };
            
            actions.appendChild(loadBtn);
            actions.appendChild(renameBtn);
            
            if (workspace.id !== 'default') {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'workspace-btn';
                deleteBtn.textContent = 'åˆ é™¤';
                deleteBtn.onclick = () => deleteWorkspace(workspace.id);
                actions.appendChild(deleteBtn);
            }
            
            item.appendChild(nameEl);
            item.appendChild(actions);
            DOM.workspaceList.appendChild(item);
        });
    }

    // === æ–‡æœ¬æ˜¾éšæ§åˆ¶ç³»ç»Ÿ ===
    function toggleTextVisibility() {
        State.textVisible = !State.textVisible;
        applyTextVisibility();
        
        // æ›´æ–°UIçŠ¶æ€
        DOM.toggleTextVisibility.classList.toggle('toggle-active', !State.textVisible);
        DOM.quickToggleText.classList.toggle('active', !State.textVisible);
        
        saveCurrentWorkspace();
        showStatus(State.textVisible ? 'æ–‡æœ¬å·²æ˜¾ç¤º' : 'æ–‡æœ¬å·²éšè—');
    }

    function applyTextVisibility() {
        document.body.classList.toggle('text-hidden', !State.textVisible);
    }

    // === æ ¸å¿ƒèŠ‚ç‚¹æ“ä½œ ===
    function getNextNodeId() { 
        return `node-${State.nodeIdCounter++}`; 
    }
    
    function getNodeById(id) { 
        return State.nodes.find(n => n.id === id); 
    }
    
    function getNodeElementById(id) { 
        return DOM.canvas.querySelector(`.node[data-id="${id}"]`); 
    }

    function calculateNodeLevel(parentId) {
        if (!parentId) return 0;
        const parent = getNodeById(parentId);
        return parent ? parent.level + 1 : 0;
    }

    function saveData() {
        saveCurrentWorkspace();
    }

    function applyCanvasTransform() {
        const transform = `translate(${State.panZoom.offsetX}px,${State.panZoom.offsetY}px) scale(${State.panZoom.scale})`;
        DOM.canvas.style.transform = transform;
        DOM.linesSvg.style.transform = transform;
        DOM.linesSvg.style.transformOrigin = '0 0';
    }

    function renderNode(node) {
        const nodeEl = document.createElement('div');
        nodeEl.className = 'node';
        if (node.level === 0) nodeEl.classList.add('root-node');
        nodeEl.dataset.id = node.id;
        nodeEl.style.left = `${node.x}px`;
        nodeEl.style.top = `${node.y}px`;
        
        // åˆ›å»ºæ–‡æœ¬æ˜¾ç¤ºå…ƒç´ 
        const textEl = document.createElement('span');
        textEl.className = 'node-text';
        textEl.textContent = node.text || '';
        nodeEl.appendChild(textEl);
        
        DOM.canvas.appendChild(nodeEl);

        // äº‹ä»¶ç»‘å®š
        nodeEl.addEventListener('mousedown', e => handleNodeMouseDown(e, node.id));
        nodeEl.addEventListener('dblclick', () => startNodeEdit(node.id));
        nodeEl.addEventListener('contextmenu', e => showNodeContextMenu(e, node.id));
    }

    function selectNode(nodeId) {
        if (State.selectedNodeId && State.selectedNodeId !== nodeId) {
            getNodeElementById(State.selectedNodeId)?.classList.remove('selected');
        }
        
        if (nodeId) {
            getNodeElementById(nodeId)?.classList.add('selected');
            State.selectedNodeId = nodeId;
        } else {
            if (State.selectedNodeId) {
                getNodeElementById(State.selectedNodeId)?.classList.remove('selected');
            }
            State.selectedNodeId = null;
        }
    }

    function createNode(parentId, text, x, y) {
        const id = getNextNodeId();
        const level = calculateNodeLevel(parentId);
        const nodeSize = level === 0 ? 40 : 26;
        let canvasX = x, canvasY = y;

        if (x === undefined || y === undefined) {
            if (State.currentLayout === 'free' || !parentId) {
                const centerX = (DOM.container.offsetWidth / 2 - State.panZoom.offsetX) / State.panZoom.scale;
                const centerY = (DOM.container.offsetHeight / 2 - State.panZoom.offsetY) / State.panZoom.scale;
                canvasX = parentId ? getNodeById(parentId).x + 120 : centerX - nodeSize / 2;
                canvasY = parentId ? getNodeById(parentId).y + 70 : centerY - nodeSize / 2;
            } else {
                canvasX = 0;
                canvasY = 0;
            }
        }
        
        const node = { id, parentId, text: text || "", x: canvasX, y: canvasY, level };
        State.nodes.push(node);
        renderNode(node);
        
        if (State.currentLayout !== 'free') {
            applyLayout(State.currentLayout);
        }
        
        drawLines();
        selectNode(id);
        if (!text) startNodeEdit(id);
        saveData();
        return node;
    }

    function startNodeEdit(nodeId) {
        if (State.activeInput) State.activeInput.blur();
        
        const node = getNodeById(nodeId);
        const nodeEl = getNodeElementById(nodeId);
        if (!node || !nodeEl) return;
        
        selectNode(nodeId);
        
        // æ˜¾ç¤ºæ–‡æœ¬ï¼ˆå³ä½¿å…¨å±€éšè—ï¼‰
        const textEl = nodeEl.querySelector('.node-text');
        if (textEl) {
            textEl.style.display = 'none';
            if (!State.textVisible) {
                textEl.classList.add('editing-temp-show');
            }
        }
        
        const inputEl = document.createElement('textarea');
        inputEl.className = 'node-input';
        inputEl.value = node.text;
        inputEl.rows = 1;
        State.activeInput = inputEl;
        
        const nodeRect = nodeEl.getBoundingClientRect();
        const containerRect = DOM.container.getBoundingClientRect();
        const nodeX = parseFloat(nodeEl.style.left);
        const nodeY = parseFloat(nodeEl.style.top);
        const nodeW = nodeEl.offsetWidth;
        
        // è¾“å…¥æ¡†ä½ç½®è®¡ç®—
        inputEl.style.width = `${Math.max(180, nodeW + 140)}px`;
        inputEl.style.left = `${nodeX + nodeW / 2 - 90}px`;
        inputEl.style.top = `${nodeY - 60}px`;

        DOM.canvas.appendChild(inputEl);
        inputEl.focus(); 
        inputEl.select();

        // è‡ªåŠ¨è°ƒæ•´é«˜åº¦
        function adjustHeight() {
            inputEl.style.height = 'auto';
            inputEl.style.height = inputEl.scrollHeight + 'px';
        }
        
        inputEl.addEventListener('input', adjustHeight);
        adjustHeight();

        inputEl.addEventListener('blur', finishEdit);
        inputEl.addEventListener('keydown', e => {
            if (e.key === 'Enter' && !e.shiftKey) { 
                e.preventDefault(); 
                finishEdit(); 
            } else if (e.key === 'Escape') { 
                inputEl.value = node.text; 
                finishEdit(); 
            }
        });

        function finishEdit() {
            if (!inputEl.parentNode) return;
            node.text = inputEl.value.trim();
            if (textEl) {
                textEl.style.display = '';
                textEl.textContent = node.text;
                textEl.classList.remove('editing-temp-show');
            }
            inputEl.parentNode.removeChild(inputEl);
            State.activeInput = null;
            saveData();
        }
    }

    // === å¸ƒå±€ç®—æ³•ç³»ç»Ÿ ===
    function applyLayout(layoutType) {
        State.currentLayout = layoutType;
        
        // æ›´æ–°èœå•æ¿€æ´»çŠ¶æ€
        document.querySelectorAll('.layout-option').forEach(item => {
            item.classList.toggle('active', item.dataset.layout === layoutType);
        });
        
        if (layoutType === 'free') {
            saveData();
            return;
        }
        
        const rootNodes = State.nodes.filter(n => n.level === 0);
        if (rootNodes.length === 0) return;
        
        switch (layoutType) {
            case 'tree':
                applyTreeLayout(rootNodes[0]);
                break;
            case 'org':
                applyOrgLayout(rootNodes[0]);
                break;
            case 'fishbone':
                applyFishboneLayout(rootNodes[0]);
                break;
        }
        
        drawLines();
        saveData();
    }

    function applyTreeLayout(rootNode) {
        const visited = new Set();
        const config = LAYOUT_CONFIG.tree;
        
        function layoutSubtree(node, x, y) {
            if (visited.has(node.id)) return { width: 0, height: 0 };
            visited.add(node.id);
            
            node.x = x;
            node.y = y;
            
            const children = State.nodes.filter(n => n.parentId === node.id);
            let totalHeight = 0;
            
            children.forEach((child, index) => {
                const childY = y + totalHeight;
                const subtree = layoutSubtree(child, x + config.nodeSpacingX, childY);
                totalHeight += subtree.height + (index < children.length - 1 ? config.nodeSpacingY : 0);
            });
            
            const nodeEl = getNodeElementById(node.id);
            if (nodeEl) {
                nodeEl.style.left = `${node.x}px`;
                nodeEl.style.top = `${node.y}px`;
            }
            
            return { 
                width: config.nodeSpacingX, 
                height: Math.max(totalHeight || config.nodeSpacingY, nodeEl ? nodeEl.offsetHeight : 40) 
            };
        }
        
        const centerY = (DOM.container.offsetHeight / 2 - State.panZoom.offsetY) / State.panZoom.scale;
        layoutSubtree(rootNode, config.startX, centerY - 20);
    }

    function applyOrgLayout(rootNode) {
        const visited = new Set();
        const config = LAYOUT_CONFIG.org;
        const levels = [];
        
        function collectLevels(node, level) {
            if (visited.has(node.id)) return;
            visited.add(node.id);
            
            if (!levels[level]) levels[level] = [];
            levels[level].push(node);
            
            const children = State.nodes.filter(n => n.parentId === node.id);
            children.forEach(child => collectLevels(child, level + 1));
        }
        
        collectLevels(rootNode, 0);
        
        const centerX = (DOM.container.offsetWidth / 2 - State.panZoom.offsetX) / State.panZoom.scale;
        
        levels.forEach((levelNodes, level) => {
            const totalWidth = levelNodes.length * config.nodeSpacingX;
            const startX = centerX - totalWidth / 2;
            
            levelNodes.forEach((node, index) => {
                node.x = startX + index * config.nodeSpacingX;
                node.y = config.startY + level * config.nodeSpacingY;
                
                const nodeEl = getNodeElementById(node.id);
                if (nodeEl) {
                    nodeEl.style.left = `${node.x}px`;
                    nodeEl.style.top = `${node.y}px`;
                }
            });
        });
    }

    function applyFishboneLayout(rootNode) {
        const config = LAYOUT_CONFIG.fishbone;
        const centerX = (DOM.container.offsetWidth / 2 - State.panZoom.offsetX) / State.panZoom.scale;
        const centerY = (DOM.container.offsetHeight / 2 - State.panZoom.offsetY) / State.panZoom.scale;
        
        rootNode.x = centerX;
        rootNode.y = centerY;
        
        const rootEl = getNodeElementById(rootNode.id);
        if (rootEl) {
            rootEl.style.left = `${rootNode.x}px`;
            rootEl.style.top = `${rootNode.y}px`;
        }
        
        const mainBranches = State.nodes.filter(n => n.parentId === rootNode.id);
        const halfCount = Math.ceil(mainBranches.length / 2);
        
        mainBranches.forEach((branch, index) => {
            const isTop = index < halfCount;
            const posIndex = isTop ? index : index - halfCount;
            
            branch.x = centerX - config.mainSpacing + posIndex * 140;
            branch.y = centerY + (isTop ? -config.branchSpacingY : config.branchSpacingY);
            
            const branchEl = getNodeElementById(branch.id);
            if (branchEl) {
                branchEl.style.left = `${branch.x}px`;
                branchEl.style.top = `${branch.y}px`;
            }
            
            layoutFishboneSubBranches(branch, isTop);
        });
    }

    function layoutFishboneSubBranches(parentNode, isTop) {
        const config = LAYOUT_CONFIG.fishbone;
        const children = State.nodes.filter(n => n.parentId === parentNode.id);
        
        children.forEach((child, index) => {
            child.x = parentNode.x + config.branchSpacingX;
            child.y = parentNode.y + (isTop ? -35 : 35) * (index + 1);
            
            const childEl = getNodeElementById(child.id);
            if (childEl) {
                childEl.style.left = `${child.x}px`;
                childEl.style.top = `${child.y}px`;
            }
            
            layoutFishboneSubBranches(child, isTop);
        });
    }

    // === è¿çº¿æ¸²æŸ“ç³»ç»Ÿ ===
    function drawLines() {
        DOM.linesSvg.innerHTML = '';
        
        State.nodes.forEach(node => {
            if (!node.parentId) return;
            const parent = getNodeById(node.parentId);
            if (!parent) return;
            const parentEl = getNodeElementById(parent.id);
            const childEl = getNodeElementById(node.id);
            if (!parentEl || !childEl) return;
            
            const px = parent.x + parentEl.offsetWidth / 2;
            const py = parent.y + parentEl.offsetHeight / 2;
            const cx = node.x + childEl.offsetWidth / 2;
            const cy = node.y + childEl.offsetHeight / 2;
            
            if (State.currentLayout === 'tree' || State.currentLayout === 'org') {
                // æ›²çº¿è·¯å¾„
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const midX = (px + cx) / 2;
                const d = `M ${px} ${py} Q ${midX} ${py} ${midX} ${(py + cy) / 2} T ${cx} ${cy}`;
                path.setAttribute('d', d);
                path.setAttribute('class', 'connection-path');
                DOM.linesSvg.appendChild(path);
            } else {
                // ç›´çº¿
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', px); 
                line.setAttribute('y1', py);
                line.setAttribute('x2', cx); 
                line.setAttribute('y2', cy);
                line.setAttribute('class', 'connection-line');
                DOM.linesSvg.appendChild(line);
            }
        });
    }

    // === æ‹–æ‹½ç³»ç»Ÿ ===
    function handleNodeMouseDown(e, nodeId) {
        if (e.button !== 0) return;
        e.stopPropagation();
        if (State.activeInput) State.activeInput.blur();
        
        const nodeEl = getNodeElementById(nodeId);
        const node = getNodeById(nodeId);
        if (!nodeEl || !node) return;
        
        selectNode(nodeId);
        State.draggingNode = nodeEl;
        const containerRect = DOM.container.getBoundingClientRect();
        const startX = (e.clientX - containerRect.left - State.panZoom.offsetX) / State.panZoom.scale;
        const startY = (e.clientY - containerRect.top - State.panZoom.offsetY) / State.panZoom.scale;
        State.dragOffset.x = startX - node.x;
        State.dragOffset.y = startY - node.y;
        
        document.addEventListener('mousemove', handleNodeMouseMove);
        document.addEventListener('mouseup', handleNodeMouseUp);
        nodeEl.style.cursor = 'grabbing'; 
        nodeEl.style.zIndex = 25;
    }

    function handleNodeMouseMove(e) {
        if (!State.draggingNode) return;
        const nodeId = State.draggingNode.dataset.id;
        const node = getNodeById(nodeId);
        const containerRect = DOM.container.getBoundingClientRect();
        const mouseX = (e.clientX - containerRect.left - State.panZoom.offsetX) / State.panZoom.scale;
        const mouseY = (e.clientY - containerRect.top - State.panZoom.offsetY) / State.panZoom.scale;
        
        // è¾¹è·é™åˆ¶
        const margin = 20;
        const maxX = (containerRect.width - State.panZoom.offsetX) / State.panZoom.scale - State.draggingNode.offsetWidth - margin;
        const maxY = (containerRect.height - State.panZoom.offsetY) / State.panZoom.scale - State.draggingNode.offsetHeight - margin;
        
        node.x = Math.max(margin, Math.min(mouseX - State.dragOffset.x, maxX));
        node.y = Math.max(margin, Math.min(mouseY - State.dragOffset.y, maxY));
        
        State.draggingNode.style.left = `${node.x}px`;
        State.draggingNode.style.top = `${node.y}px`;
        drawLines();
    }

    function handleNodeMouseUp() {
        if (!State.draggingNode) return;
        State.draggingNode.style.cursor = 'pointer';
        State.draggingNode.style.zIndex = 10;
        State.draggingNode = null;
        document.removeEventListener('mousemove', handleNodeMouseMove);
        document.removeEventListener('mouseup', handleNodeMouseUp);
        saveData();
    }

    // === ç”»å¸ƒå¹³ç§»ä¸ç¼©æ”¾ ===
    DOM.container.addEventListener('mousedown', e => {
        if (e.target !== DOM.container && e.target !== DOM.canvas && e.target !== DOM.linesSvg) return;
        if (e.button !== 0 && e.button !== 1) return;
        if (State.activeInput) State.activeInput.blur();
        
        State.panZoom.isPanning = true;
        State.panZoom.lastPanX = e.clientX;
        State.panZoom.lastPanY = e.clientY;
        DOM.container.classList.add('grabbing');
        selectNode(null); 
        hideContextMenu(); 
        hideMenus();
    });
    
    document.addEventListener('mousemove', e => {
        if (!State.panZoom.isPanning) return;
        const dx = e.clientX - State.panZoom.lastPanX;
        const dy = e.clientY - State.panZoom.lastPanY;
        State.panZoom.offsetX += dx;
        State.panZoom.offsetY += dy;
        State.panZoom.lastPanX = e.clientX; 
        State.panZoom.lastPanY = e.clientY;
        applyCanvasTransform();
    });
    
    document.addEventListener('mouseup', () => {
        if (State.panZoom.isPanning) {
            State.panZoom.isPanning = false;
            DOM.container.classList.remove('grabbing');
            saveData();
        }
    });
    
    DOM.container.addEventListener('wheel', e => {
        e.preventDefault();
        if (State.activeInput) State.activeInput.blur();
        
        const scaleAmount = 1.1;
        const containerRect = DOM.container.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const mouseY = e.clientY - containerRect.top;
        
        const prevScale = State.panZoom.scale;
        
        if (e.deltaY < 0) {
            State.panZoom.scale = Math.min(State.panZoom.scale * scaleAmount, 5);
        } else {
            State.panZoom.scale = Math.max(State.panZoom.scale / scaleAmount, 0.1);
        }
        
        const scaleDiff = State.panZoom.scale / prevScale;
        State.panZoom.offsetX = mouseX - (mouseX - State.panZoom.offsetX) * scaleDiff;
        State.panZoom.offsetY = mouseY - (mouseY - State.panZoom.offsetY) * scaleDiff;
        
        applyCanvasTransform(); 
        drawLines(); 
        saveData();
    });

    // === æ™ºèƒ½èšç„¦ç³»ç»Ÿ ===
    function focusOnNode(nodeId) {
        const node = getNodeById(nodeId);
        const nodeEl = getNodeElementById(nodeId);
        if (!node || !nodeEl) return;
        
        const containerRect = DOM.container.getBoundingClientRect();
        const targetScale = 1.5;
        
        State.panZoom.scale = targetScale;
        State.panZoom.offsetX = containerRect.width / 2 - (node.x + nodeEl.offsetWidth / 2) * targetScale;
        State.panZoom.offsetY = containerRect.height / 2 - (node.y + nodeEl.offsetHeight / 2) * targetScale;
        
        applyCanvasTransform();
        drawLines();
        selectNode(nodeId);
        saveData();
        
        showStatus('å·²èšç„¦åˆ°èŠ‚ç‚¹');
    }

    function focusOnRootNode() {
        const rootNode = State.nodes.find(n => n.level === 0);
        if (rootNode) {
            focusOnNode(rootNode.id);
        } else {
            showStatus('æœªæ‰¾åˆ°æ ¹èŠ‚ç‚¹');
        }
    }

    // === å³é”®èœå•ç³»ç»Ÿ ===
    let contextMenuNodeId = null;
    
    function showNodeContextMenu(e, nodeId) {
        e.preventDefault();
        if (State.activeInput) State.activeInput.blur();
        selectNode(nodeId);
        contextMenuNodeId = nodeId;
        DOM.contextMenu.style.display = 'block';
        
        const menuWidth = DOM.contextMenu.offsetWidth;
        const menuHeight = DOM.contextMenu.offsetHeight;
        let x = e.clientX, y = e.clientY;
        
        if (x + menuWidth > window.innerWidth) x = window.innerWidth - menuWidth - 5;
        if (y + menuHeight > window.innerHeight) y = window.innerHeight - menuHeight - 5;
        
        DOM.contextMenu.style.left = `${x}px`;
        DOM.contextMenu.style.top = `${y}px`;
    }
    
    function hideContextMenu() {
        DOM.contextMenu.style.display = 'none';
        contextMenuNodeId = null;
    }

    // === èŠ‚ç‚¹åˆ é™¤ç³»ç»Ÿ ===
    function deleteNodeRecursive(nodeId) {
        const children = State.nodes.filter(n => n.parentId === nodeId);
        children.forEach(child => deleteNodeRecursive(child.id));
        
        const nodeEl = getNodeElementById(nodeId);
        if (nodeEl) nodeEl.remove();
        
        State.nodes = State.nodes.filter(n => n.id !== nodeId);
        
        if (State.selectedNodeId === nodeId) selectNode(null);
    }
    
    function handleDeleteNode(nodeId) {
        if (!nodeId || !getNodeById(nodeId)) return;
        
        if (confirm('ç¡®å®šè¦åˆ é™¤æ­¤èŠ‚ç‚¹åŠå…¶æ‰€æœ‰å­èŠ‚ç‚¹å—ï¼Ÿ')) {
            deleteNodeRecursive(nodeId);
            drawLines();
            saveData();
            showStatus('èŠ‚ç‚¹å·²åˆ é™¤');
        }
    }

    // === èœå•ç³»ç»Ÿ ===
    function toggleMenu() {
        State.isMenuOpen = !State.isMenuOpen;
        DOM.menuOptions.style.display = State.isMenuOpen ? 'block' : 'none';
    }
    
    function hideMenus() {
        if (State.isMenuOpen) {
            DOM.menuOptions.style.display = 'none';
            State.isMenuOpen = false;
        }
        DOM.bgPresetPanel.style.display = 'none';
        DOM.colorPickerPanel.style.display = 'none';
        DOM.workspacePanel.style.display = 'none';
    }

    // === èƒŒæ™¯ç³»ç»Ÿ ===
    function applyBackground() {
        if (State.currentBackground.startsWith('#')) {
            document.body.style.background = State.currentBackground;
        } else {
            document.body.style.background = `${State.currentBackground} center/cover no-repeat`;
            document.body.style.backgroundColor = '#0f142b';
        }
    }

    // === çŠ¶æ€æç¤ºç³»ç»Ÿ ===
    function showStatus(message, duration = 2000) {
        DOM.statusIndicator.textContent = message;
        DOM.statusIndicator.style.display = 'block';
        
        setTimeout(() => {
            DOM.statusIndicator.style.display = 'none';
        }, duration);
    }

    // === å¯¼å…¥å¯¼å‡ºç³»ç»Ÿ ===
    function exportWorkspaceData() {
        saveCurrentWorkspace();
        const workspace = State.workspaces[State.currentWorkspaceId];
        if (!workspace) return;
        
        const exportData = {
            workspaceName: workspace.name,
            exportDate: new Date().toISOString(),
            data: workspace.data
        };
        
        const json = JSON.stringify(exportData, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `æ€ç»´å¯¼å›¾_${workspace.name}_${new Date().toISOString().slice(0, 10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus('å¯¼å‡ºæˆåŠŸ');
    }

    function importWorkspaceData(fileInput) {
        const file = fileInput.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = e => {
            try {
                const imported = JSON.parse(e.target.result);
                if (imported && imported.data) {
                    const workspaceName = imported.workspaceName || 'å¯¼å…¥çš„å·¥ä½œåŒº';
                    createNewWorkspace(workspaceName);
                    
                    // åŠ è½½å¯¼å…¥çš„æ•°æ®åˆ°æ–°å·¥ä½œåŒº
                    const newWorkspaceId = Object.keys(State.workspaces).pop();
                    State.workspaces[newWorkspaceId].data = imported.data;
                    saveWorkspaces();
                    loadWorkspace(newWorkspaceId);
                    
                    showStatus('å¯¼å…¥æˆåŠŸ');
                } else {
                    showStatus('æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                }
            } catch (err) {
                showStatus('å¯¼å…¥å¤±è´¥ï¼š' + err.message);
            }
        };
        reader.readAsText(file);
    }

    // === äº‹ä»¶ç»‘å®š ===
    
    // ä¸»èœå•
    DOM.menuToggle.addEventListener('click', e => {
        e.stopPropagation();
        if (State.activeInput) State.activeInput.blur();
        toggleMenu();
    });
    
    // å¿«é€Ÿå·¥å…·æ 
    DOM.quickAddChild.addEventListener('click', () => {
        if (State.selectedNodeId) {
            const parent = getNodeById(State.selectedNodeId);
            if (parent) {
                createNode(State.selectedNodeId, "", parent.x + 150, parent.y + 80);
            }
        } else {
            showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹');
        }
    });
    
    DOM.quickToggleText.addEventListener('click', toggleTextVisibility);
    DOM.quickFocusRoot.addEventListener('click', focusOnRootNode);
    DOM.quickExport.addEventListener('click', exportWorkspaceData);
    
    // èœå•é¡¹
    DOM.addRootNode.addEventListener('click', () => {
        if (State.activeInput) State.activeInput.blur();
        const rootExists = State.nodes.some(n => n.level === 0);
        if (rootExists) {
            showStatus('å·²å­˜åœ¨æ ¹èŠ‚ç‚¹');
            return;
        }
        const x = DOM.container.offsetWidth / 2;
        const y = DOM.container.offsetHeight / 2;
        createNode(null, "æ ¸å¿ƒä¸»é¢˜", x, y);
        hideMenus();
    });
    
    DOM.toggleTextVisibility.addEventListener('click', () => {
        toggleTextVisibility();
        hideMenus();
    });
    
    DOM.workspaceManager.addEventListener('click', () => {
        updateWorkspaceList();
        DOM.workspacePanel.style.display = 'block';
        hideMenus();
    });
    
    DOM.clearMap.addEventListener('click', () => {
        if (State.activeInput) State.activeInput.blur();
        if (State.nodes.length === 0) {
            showStatus('ç”»å¸ƒå·²ç»æ˜¯ç©ºçš„');
            return;
        }
        if (confirm('ç¡®å®šè¦æ¸…ç©ºå½“å‰å·¥ä½œåŒºçš„æ‰€æœ‰èŠ‚ç‚¹å—ï¼Ÿ')) {
            DOM.canvas.innerHTML = ''; 
            DOM.linesSvg.innerHTML = '';
            State.nodes = []; 
            State.nodeIdCounter = 0; 
            State.selectedNodeId = null;
            State.currentLayout = 'free';
            State.panZoom = { scale: 1, offsetX: 0, offsetY: 0, isPanning: false, lastPanX: 0, lastPanY: 0 };
            applyCanvasTransform(); 
            saveData();
            showStatus('ç”»å¸ƒå·²æ¸…ç©º');
        }
        hideMenus();
    });
    
    DOM.exportJSON.addEventListener('click', () => {
        if (State.activeInput) State.activeInput.blur();
        if (State.nodes.length === 0) { 
            showStatus('æ²¡æœ‰æ•°æ®å¯ä»¥å¯¼å‡º'); 
            return; 
        }
        exportWorkspaceData();
        hideMenus();
    });
    
    DOM.importJSON.addEventListener('click', () => {
        if (State.activeInput) State.activeInput.blur();
        const fileInput = document.createElement('input');
        fileInput.type = 'file'; 
        fileInput.accept = '.json,application/json';
        fileInput.onchange = () => importWorkspaceData(fileInput);
        fileInput.click();
        hideMenus();
    });
    
    DOM.exportImage.addEventListener('click', () => {
        if (State.activeInput) State.activeInput.blur();
        showStatus('å›¾ç‰‡å¯¼å‡ºåŠŸèƒ½å¼€å‘ä¸­ï¼Œè¯·ä½¿ç”¨æµè§ˆå™¨æˆªå›¾');
        hideMenus();
    });

    // å·¥ä½œåŒºç®¡ç†
    DOM.createWorkspace.addEventListener('click', () => {
        const name = DOM.newWorkspaceName.value.trim();
        if (name) {
            createNewWorkspace(name);
            DOM.newWorkspaceName.value = '';
            DOM.workspacePanel.style.display = 'none';
        } else {
            showStatus('è¯·è¾“å…¥å·¥ä½œåŒºåç§°');
        }
    });
    
    DOM.closeWorkspacePanel.addEventListener('click', () => {
        DOM.workspacePanel.style.display = 'none';
    });
    
    DOM.newWorkspaceName.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
            DOM.createWorkspace.click();
        }
    });

    // å¸ƒå±€åˆ‡æ¢
    document.querySelectorAll('.layout-option').forEach(item => {
        item.addEventListener('click', () => {
            const layout = item.dataset.layout;
            if (layout !== State.currentLayout) {
                applyLayout(layout);
            }
            hideMenus();
        });
    });

    // èƒŒæ™¯è®¾ç½®
    DOM.bgPresets.addEventListener('click', e => {
        e.stopPropagation();
        DOM.bgPresetPanel.style.display = DOM.bgPresetPanel.style.display === 'block' ? 'none' : 'block';
        DOM.colorPickerPanel.style.display = 'none';
    });

    DOM.bgColor.addEventListener('click', e => {
        e.stopPropagation();
        DOM.colorPickerPanel.style.display = DOM.colorPickerPanel.style.display === 'block' ? 'none' : 'block';
        DOM.bgPresetPanel.style.display = 'none';
    });

    document.querySelectorAll('.bg-preset-item').forEach(item => {
        item.addEventListener('click', () => {
            const bg = item.dataset.bg;
            State.currentBackground = bg;
            applyBackground();
            
            document.querySelectorAll('.bg-preset-item').forEach(i => i.classList.remove('active'));
            item.classList.add('active');
            
            saveData();
            DOM.bgPresetPanel.style.display = 'none';
            showStatus('èƒŒæ™¯å·²æ›´æ¢');
        });
    });

    DOM.applyColorBg.addEventListener('click', () => {
        const color = DOM.bgColorPicker.value;
        State.currentBackground = color;
        applyBackground();
        saveData();
        DOM.colorPickerPanel.style.display = 'none';
        showStatus('èƒŒæ™¯é¢œè‰²å·²åº”ç”¨');
    });

    // å³é”®èœå•
    DOM.ctxAddChild.addEventListener('click', () => {
        if (State.activeInput) State.activeInput.blur();
        if (State.selectedNodeId) {
            const parent = getNodeById(State.selectedNodeId);
            if (parent) {
                let childX, childY;
                if (State.currentLayout === 'free') {
                    childX = parent.x + 100 * (Math.random() > 0.5 ? 1 : -1);
                    childY = parent.y + 60 * (Math.random() > 0.5 ? 1 : -1);
                } else {
                    childX = parent.x + 150;
                    childY = parent.y;
                }
                createNode(State.selectedNodeId, "", childX, childY);
            }
        }
        hideContextMenu();
    });
    
    DOM.ctxEditNode.addEventListener('click', () => {
        if (State.selectedNodeId) startNodeEdit(State.selectedNodeId);
        hideContextMenu();
    });
    
    DOM.ctxDeleteNode.addEventListener('click', () => {
        if (State.activeInput) State.activeInput.blur();
        if (State.selectedNodeId) {
            handleDeleteNode(State.selectedNodeId);
        }
        hideContextMenu();
    });
    
    DOM.ctxFocusNode.addEventListener('click', () => {
        if (contextMenuNodeId) {
            focusOnNode(contextMenuNodeId);
        }
        hideContextMenu();
    });

    // å…¨å±€ç‚¹å‡»äº‹ä»¶
    document.addEventListener('click', event => {
        if (DOM.contextMenu.style.display === 'block' && 
            !DOM.contextMenu.contains(event.target) && 
            !event.target.closest('.node')) {
            hideContextMenu();
        }
        
        if (State.isMenuOpen && 
            event.target !== DOM.menuToggle && 
            !DOM.menuOptions.contains(event.target) &&
            !DOM.bgPresetPanel.contains(event.target) &&
            !DOM.colorPickerPanel.contains(event.target) &&
            !DOM.workspacePanel.contains(event.target)) {
            hideMenus();
        }
    }, true);

    // é”®ç›˜å¿«æ·é”®
    document.addEventListener('keydown', e => {
        // Ctrl/Cmd + S: ä¿å­˜
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            saveData();
            showStatus('å·²ä¿å­˜');
        }
        
        // Ctrl/Cmd + E: å¯¼å‡º
        if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
            e.preventDefault();
            exportWorkspaceData();
        }
        
        // Ctrl/Cmd + H: åˆ‡æ¢æ–‡æœ¬æ˜¾éš
        if ((e.ctrlKey || e.metaKey) && e.key === 'h') {
            e.preventDefault();
            toggleTextVisibility();
        }
        
        // Delete: åˆ é™¤é€‰ä¸­èŠ‚ç‚¹
        if (e.key === 'Delete' && State.selectedNodeId && !State.activeInput) {
            handleDeleteNode(State.selectedNodeId);
        }
        
        // Tab: æ·»åŠ å­èŠ‚ç‚¹
        if (e.key === 'Tab' && State.selectedNodeId && !State.activeInput) {
            e.preventDefault();
            const parent = getNodeById(State.selectedNodeId);
            if (parent) {
                createNode(State.selectedNodeId, "", parent.x + 150, parent.y + 80);
            }
        }
    });

    // === åˆå§‹åŒ–ç³»ç»Ÿ ===
    function init() {
        initWorkspaceSystem();
        
        // åŠ è½½é»˜è®¤å·¥ä½œåŒº
        const lastWorkspaceId = localStorage.getItem('quantum_last_workspace') || 'default';
        if (State.workspaces[lastWorkspaceId]) {
            loadWorkspace(lastWorkspaceId);
        } else {
            loadWorkspace('default');
        }
        
        // å¦‚æœå·¥ä½œåŒºä¸ºç©ºï¼Œåˆ›å»ºåˆå§‹èŠ‚ç‚¹
        if (State.nodes.length === 0) {
            createNode(null, "æ ¸å¿ƒä¸»é¢˜", DOM.container.offsetWidth / 2, DOM.container.offsetHeight / 2);
        }
        
        // ä¿å­˜æœ€åä½¿ç”¨çš„å·¥ä½œåŒº
        window.addEventListener('beforeunload', () => {
            saveCurrentWorkspace();
            localStorage.setItem('quantum_last_workspace', State.currentWorkspaceId);
        });
        
        showStatus('é‡å­æ€ç»´å¯¼å›¾å·²å°±ç»ª');
    }
    
    // å¯åŠ¨ç³»ç»Ÿ
    requestAnimationFrame(init);
});
    </script>
</body>
</html>